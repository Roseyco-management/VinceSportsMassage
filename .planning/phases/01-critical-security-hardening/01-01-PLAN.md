---
phase: 01-critical-security-hardening
plan: 01
type: execute
---

<objective>
Eliminate HIGH severity XSS vulnerability in blog post rendering by implementing server-side HTML sanitization with DOMPurify + jsdom.

Purpose: Protect users from malicious scripts in blog content that could steal data, hijack sessions, or perform unauthorized actions. This is the #1 security priority per PROJECT.md Core Value.

Output: Blog content sanitized on server before rendering, XSS vulnerability eliminated, zero breaking changes to visual design.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-critical-security-hardening/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md
@src/app/(marketing)/blog/[slug]/blog-post-page.tsx
@src/lib/supabase/server.ts

**Tech stack available:**
- Next.js 16 App Router with Server Components
- TypeScript strict mode
- React 19.2.0
- Node.js 20+ (crypto module available)

**Established patterns:**
- Server Components for data fetching and rendering
- Utility functions in `src/lib/` directory
- Type-safe with TypeScript interfaces

**Constraining decisions:**
- DOMPurify selected for HTML sanitization (industry-standard)
- jsdom 20.0.0+ required (v19 has XSS vulnerabilities)
- Must work in Next.js 16 Server Components context
- Zero breaking changes to visual design

**Current vulnerability:**
- `src/app/(marketing)/blog/[slug]/blog-post-page.tsx:138` uses `dangerouslySetInnerHTML` with unsanitized `post.content`
- Blog content comes from n8n webhook (external source)
- XSS attack vector: Malicious HTML in blog content executes in user browser

**Research findings (from 01-RESEARCH.md):**
- Use DOMPurify 3.3.1+ with jsdom 20.0.0+
- Manual DOMPurify + jsdom initialization more reliable than isomorphic-dompurify for Next.js App Router
- Restrictive allowlist approach (only allow necessary tags)
- Sanitize on server before rendering to protect SSR/SSG
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install DOMPurify and jsdom dependencies</name>
  <files>package.json</files>
  <action>
Install DOMPurify and jsdom with TypeScript types:
```bash
npm install dompurify jsdom
npm install --save-dev @types/dompurify @types/jsdom
```

Verify versions meet security requirements:
- dompurify: 3.3.1 or higher
- jsdom: 20.0.0 or higher

Do NOT use isomorphic-dompurify (has reported issues with Next.js App Router per RESEARCH.md). Use manual initialization for guaranteed compatibility.
  </action>
  <verify>Check package.json shows dompurify and jsdom in dependencies, @types packages in devDependencies. Run `npm list dompurify jsdom` to confirm versions >=3.3.1 and >=20.0.0.</verify>
  <done>Dependencies installed with correct versions, package.json and package-lock.json updated</done>
</task>

<task type="auto">
  <name>Task 2: Create server-side HTML sanitization utility</name>
  <files>src/lib/sanitize.ts</files>
  <action>
Create `src/lib/sanitize.ts` with server-side DOMPurify + jsdom initialization:

1. Import JSDOM and DOMPurify
2. Create jsdom window instance (empty document)
3. Initialize DOMPurify with the window
4. Export `sanitizeHtml(dirty: string): string` function
5. Use RESTRICTIVE allowlist configuration based on RESEARCH.md:
   - ALLOWED_TAGS: Only permit safe HTML elements needed for blog formatting
     - Text formatting: p, br, strong, em, b, i, u
     - Headings: h1, h2, h3, h4, h5, h6
     - Lists: ul, ol, li
     - Other: a, blockquote, code, pre
   - ALLOWED_ATTR: Only href, target, rel, class
   - ALLOW_DATA_ATTR: false (prevent data- attributes)
   - ALLOW_UNKNOWN_PROTOCOLS: false (prevent javascript: and other dangerous protocols)
6. Add TypeScript type safety with return type

Implementation pattern from RESEARCH.md:
```typescript
import { JSDOM } from 'jsdom';
import DOMPurify from 'dompurify';

const window = new JSDOM('').window;
const purify = DOMPurify(window as unknown as Window);

export function sanitizeHtml(dirty: string): string {
  return purify.sanitize(dirty, {
    ALLOWED_TAGS: [...],
    ALLOWED_ATTR: [...],
    ALLOW_DATA_ATTR: false,
    ALLOW_UNKNOWN_PROTOCOLS: false,
  });
}
```

CRITICAL: Use restrictive allowlist. It's easier to add tags later than to fix XSS vulnerability. If blog posts break visually, we add tags - but we start secure.
  </action>
  <verify>File exists at src/lib/sanitize.ts, exports sanitizeHtml function, TypeScript compiles without errors. Test basic sanitization: `sanitizeHtml('<script>alert("xss")</script><p>Safe</p>')` should return only `<p>Safe</p>`.</verify>
  <done>sanitizeHtml utility created, removes scripts and dangerous content, allows safe formatting tags</done>
</task>

<task type="auto">
  <name>Task 3: Replace dangerouslySetInnerHTML with sanitized content in blog post page</name>
  <files>src/app/(marketing)/blog/[slug]/blog-post-page.tsx</files>
  <action>
Update blog post rendering to use sanitized HTML:

1. Import sanitizeHtml from '@/lib/sanitize' at top of file
2. Locate line 138 where `dangerouslySetInnerHTML={{ __html: post.content }}` is used
3. Replace with sanitized version:
   ```typescript
   const cleanContent = sanitizeHtml(post.content);

   // Then in JSX:
   dangerouslySetInnerHTML={{ __html: cleanContent }}
   ```
4. Sanitize BEFORE the return statement, not inline in JSX (better for debugging)
5. Keep all existing className and prose styling unchanged
6. Do NOT modify any other parts of the component (share buttons, metadata, etc.)

This is a Server Component (no "use client"), so sanitization happens during SSR/SSG - protects all users including those viewing cached pages.

IMPORTANT: Only change the content sanitization. All visual styling, layout, and other functionality must remain identical. This is a security fix, not a redesign.
  </action>
  <verify>Build succeeds with `npm run build`, TypeScript has no errors. Visually inspect a blog post at /blog/[any-slug] - formatting should look identical to before. View page source and confirm <script> tags (if any were in content) are removed.</verify>
  <done>Blog post content is sanitized before rendering, XSS vulnerability eliminated, visual design unchanged, build passes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors or warnings
- [ ] TypeScript compilation passes with no type errors
- [ ] Blog post page renders correctly at /blog/[slug] with identical visual styling
- [ ] Test with XSS payload: If you can add a test blog post with `<script>alert('xss')</script>` in content, it should be stripped and NOT execute
- [ ] All existing blog posts still display with proper formatting
</verification>

<success_criteria>
- All tasks completed
- DOMPurify and jsdom installed (v3.3.1+ and v20.0.0+)
- sanitizeHtml utility created with restrictive allowlist
- Blog post page uses sanitized content
- XSS vulnerability eliminated (scripts stripped from content)
- Zero visual regressions (formatting looks identical)
- No TypeScript errors or build warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-security-hardening/01-01-SUMMARY.md`:

# Phase 1 Plan 1: HTML Sanitization with DOMPurify Summary

**XSS vulnerability eliminated from blog post rendering using server-side DOMPurify + jsdom sanitization**

## Accomplishments

- Installed DOMPurify 3.3.1+ and jsdom 20.0.0+ with TypeScript types
- Created `src/lib/sanitize.ts` utility with restrictive allowlist configuration
- Updated blog post page to sanitize HTML before rendering
- XSS attack vector closed: malicious scripts in blog content now stripped
- Zero breaking changes to visual design or functionality

## Files Created/Modified

- `package.json` - Added dompurify, jsdom, @types/dompurify, @types/jsdom
- `src/lib/sanitize.ts` - Created sanitization utility with DOMPurify + jsdom
- `src/app/(marketing)/blog/[slug]/blog-post-page.tsx` - Replaced unsanitized dangerouslySetInnerHTML with sanitized content

## Decisions Made

- Used manual DOMPurify + jsdom initialization instead of isomorphic-dompurify (better Next.js App Router compatibility)
- Applied restrictive allowlist: only safe formatting tags permitted (can expand if needed)
- Sanitization happens in Server Component (protects SSR/SSG renders, not just client-side)

## Issues Encountered

[Document any issues, or write "None"]

## Next Step

Ready for 01-02-PLAN.md (Webhook Authentication Hardening)
</output>
