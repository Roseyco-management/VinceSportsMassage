---
phase: 01-critical-security-hardening
plan: 02
type: execute
---

<objective>
Eliminate MEDIUM severity timing attack vulnerability in webhook authentication by replacing string comparison with crypto.timingSafeEqual for constant-time verification.

Purpose: Prevent attackers from guessing the webhook secret through timing analysis. Timing attacks can leak information character-by-character by measuring response times, allowing unauthorized access to the blog API.

Output: Webhook authentication hardened with timing-safe comparison, n8n integration remains functional, unauthorized webhook requests rejected.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-critical-security-hardening/01-RESEARCH.md
@.planning/phases/01-critical-security-hardening/01-01-SUMMARY.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/INTEGRATIONS.md
@src/app/api/blog/route.ts

**Tech stack available:**
- Node.js crypto module (built-in, no installation needed)
- Next.js 16 App Router API routes
- TypeScript strict mode

**Established patterns:**
- API routes in `src/app/api/` directory
- Utility functions in `src/lib/` directory
- Environment variables for secrets

**Constraining decisions:**
- crypto.timingSafeEqual selected for timing-safe comparison (built-in, no dependencies)
- Must maintain compatibility with existing n8n webhook integration
- Raw body access required for HMAC verification (if adding HMAC in future)

**Current vulnerability:**
- `src/app/api/blog/route.ts:38` uses direct string comparison: `webhookSecret !== process.env.N8N_WEBHOOK_SECRET`
- Standard !== operator returns immediately on first non-matching character
- Timing differences leak information about secret content
- Attacker can guess secret character-by-character by measuring response times

**Research findings (from 01-RESEARCH.md):**
- Always use crypto.timingSafeEqual for cryptographic comparisons
- Convert strings to Buffers before comparison
- Check buffer lengths match before calling timingSafeEqual (throws if different lengths)
- Pattern used by Stripe, GitHub, Shopify for webhook verification
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timing-safe webhook verification utility</name>
  <files>src/lib/webhook-auth.ts</files>
  <action>
Create `src/lib/webhook-auth.ts` with timing-safe webhook secret verification:

1. Import crypto.timingSafeEqual from 'crypto' (Node.js built-in)
2. Export `verifyWebhookSecret(receivedSecret: string, expectedSecret: string): boolean` function
3. Implementation pattern from RESEARCH.md:
   - Convert both strings to UTF-8 Buffers
   - Check lengths match (timingSafeEqual throws error if lengths differ)
   - Use crypto.timingSafeEqual for constant-time comparison
   - Wrap in try-catch to handle errors gracefully
   - Return false on any error (fail closed)

```typescript
import { timingSafeEqual } from 'crypto';

export function verifyWebhookSecret(
  receivedSecret: string,
  expectedSecret: string
): boolean {
  try {
    // Convert to buffers
    const receivedBuffer = Buffer.from(receivedSecret, 'utf8');
    const expectedBuffer = Buffer.from(expectedSecret, 'utf8');

    // Check lengths (timingSafeEqual throws if different)
    if (receivedBuffer.length !== expectedBuffer.length) {
      return false;
    }

    // Constant-time comparison
    return timingSafeEqual(receivedBuffer, expectedBuffer);
  } catch (error) {
    // Log error but don't expose details
    console.error('Webhook verification error:', error);
    return false;
  }
}
```

CRITICAL: The comparison takes the same time regardless of where strings differ. This prevents timing attacks where attackers measure response times to guess secrets.

Add TypeScript types for clarity and export function with clear documentation comment explaining why timing-safe comparison is necessary.
  </action>
  <verify>File exists at src/lib/webhook-auth.ts, exports verifyWebhookSecret function, TypeScript compiles. Test: `verifyWebhookSecret('abc', 'abc')` returns true, `verifyWebhookSecret('abc', 'xyz')` returns false, both take approximately same time.</verify>
  <done>Timing-safe webhook verification utility created with crypto.timingSafeEqual</done>
</task>

<task type="auto">
  <name>Task 2: Update blog API route to use timing-safe comparison</name>
  <files>src/app/api/blog/route.ts</files>
  <action>
Update webhook secret verification in POST handler:

1. Import verifyWebhookSecret from '@/lib/webhook-auth' at top of file
2. Locate line 38 where current comparison happens:
   ```typescript
   if (webhookSecret !== process.env.N8N_WEBHOOK_SECRET) {
   ```
3. Replace with timing-safe comparison:
   ```typescript
   const expectedSecret = process.env.N8N_WEBHOOK_SECRET;
   if (!expectedSecret || !webhookSecret) {
     console.error('Missing webhook secret');
     return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
   }

   if (!verifyWebhookSecret(webhookSecret, expectedSecret)) {
     console.error('Invalid webhook secret');
     return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
   }
   ```
4. Add explicit check for missing secrets (defensive programming)
5. Keep all other logic unchanged (validation, slug generation, database operations, etc.)
6. Maintain exact same error responses and status codes (401 for unauthorized)

IMPORTANT: This change only affects HOW the comparison happens, not WHAT is being compared. The n8n webhook integration continues working exactly as before - just with timing-safe verification.

Why this matters: An attacker can no longer guess the webhook secret by measuring how long authentication takes. All comparisons take constant time regardless of where secrets differ.
  </action>
  <verify>Build succeeds with `npm run build`, TypeScript has no errors. Test webhook endpoint: valid webhook secret (from .env N8N_WEBHOOK_SECRET) returns 200, invalid secret returns 401. Both requests take approximately same time (use `time curl` to measure).</verify>
  <done>Blog API webhook authentication uses crypto.timingSafeEqual, timing attack vulnerability eliminated, n8n integration still works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors or warnings
- [ ] TypeScript compilation passes with no type errors
- [ ] Webhook endpoint responds to valid secrets (test with curl or n8n)
- [ ] Webhook endpoint rejects invalid secrets with 401
- [ ] Timing attack closed: comparisons take constant time regardless of secret match/mismatch
- [ ] No changes to other API route functionality (blog post creation still works)
</verification>

<success_criteria>
- All tasks completed
- Timing-safe webhook verification utility created
- Blog API route uses crypto.timingSafeEqual for secret comparison
- Timing attack vulnerability eliminated
- n8n webhook integration remains fully functional
- No TypeScript errors or build warnings
- All authentication responses take constant time
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-security-hardening/01-02-SUMMARY.md`:

# Phase 1 Plan 2: Webhook Authentication Hardening Summary

**Timing attack vulnerability eliminated from n8n webhook authentication using crypto.timingSafeEqual for constant-time comparison**

## Accomplishments

- Created `src/lib/webhook-auth.ts` utility with timing-safe secret verification
- Updated blog API route to use crypto.timingSafeEqual instead of standard !== comparison
- Timing attack vector closed: secret comparison now constant-time
- Added defensive checks for missing secrets
- n8n webhook integration continues working without changes

## Files Created/Modified

- `src/lib/webhook-auth.ts` - Created timing-safe webhook verification utility
- `src/app/api/blog/route.ts` - Replaced string comparison with timing-safe verification

## Decisions Made

- Used Node.js built-in crypto.timingSafeEqual (no external dependencies)
- Added explicit null checks for missing secrets (fail closed)
- Wrapped in try-catch to handle buffer length mismatches gracefully
- Maintained identical error responses (401) to preserve n8n compatibility

## Issues Encountered

[Document any issues, or write "None"]

## Next Phase Readiness

**Phase 1 Complete**: All critical security vulnerabilities addressed
- XSS vulnerability: Eliminated via DOMPurify sanitization ✅
- Timing attack vulnerability: Eliminated via crypto.timingSafeEqual ✅

**Phase 2 Prerequisites Met**:
- Security foundation established
- Utility pattern created (can extend for Zod validation utilities)
- Ready for input validation and structured logging

## Next Step

Phase 1 complete. Ready for Phase 2: Input Validation & Error Handling
</output>
