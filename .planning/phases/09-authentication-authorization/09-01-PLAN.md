---
phase: 09-authentication-authorization
plan: 01
type: execute
---

<objective>
Set up Supabase Auth with email/password authentication, implement role-based access control for admin users, and protect admin routes with Next.js middleware.

Purpose: Establish the authentication foundation that all admin dashboard features depend on. Secure admin routes so only authenticated admin users can access content management and analytics interfaces.
Output: Working authentication system with login/logout, protected /admin routes, and admin role verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md
@src/lib/supabase/client.ts
@src/lib/supabase/server.ts
@src/lib/env.ts

**Tech stack available:**
- Supabase Auth (@supabase/ssr ^0.8.0, @supabase/supabase-js ^2.86.0)
- Next.js 16 App Router with Server Components
- Zod for validation (already used in v1.0)
- TypeScript strict mode
- Existing Supabase client/server setup with SSR support

**Established patterns:**
- Server/client component split with "use client" directive
- Zod validation for API inputs (src/lib/validation.ts)
- Centralized environment validation (src/lib/env.ts)
- Error handling with try-catch and structured logging (src/lib/logger.ts)
- Path aliases (@/*) for imports
- Named exports for components, default for pages

**Constraining decisions:**
- v1.1: Supabase Auth chosen (existing infrastructure, no new services)
- v1.1: Admin routes at /admin (separate from marketing site)
- v1.0: Zod for input validation (established in security remediation)
- v1.0: Centralized env validation (no non-null assertions)

**Project constraints:**
- Zero breaking changes to marketing site
- Maintain current Supabase setup
- Use existing shadcn/ui components for consistency
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Supabase Auth policies and create admin user table</name>
  <files>supabase/migrations/001_auth_setup.sql</files>
  <action>
Create Supabase migration file that:
1. Creates `admin_users` table with columns: id (uuid, references auth.users), email (text), role (text, default 'admin'), created_at (timestamptz), updated_at (timestamptz)
2. Adds RLS policies: only authenticated users can read their own admin_users row
3. Creates index on email for fast lookups
4. Adds trigger to auto-update updated_at timestamp

Use Supabase SQL conventions: enable RLS with `ALTER TABLE admin_users ENABLE ROW LEVEL SECURITY`, use `auth.uid()` for current user checks.

DO NOT use custom auth tables for credentials - Supabase Auth manages that. This admin_users table is ONLY for role tracking and linking to auth.users.
  </action>
  <verify>cat supabase/migrations/001_auth_setup.sql shows CREATE TABLE, RLS policies, index, and trigger</verify>
  <done>Migration file exists with admin_users table, RLS enabled, policies defined, no syntax errors</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <action>Apply Supabase migration to create admin_users table</action>
  <instructions>
I created the migration file at supabase/migrations/001_auth_setup.sql.

To apply it to your Supabase database:
1. Option A (Supabase Dashboard): Go to SQL Editor in Supabase dashboard, paste the migration content, run query
2. Option B (CLI): If you have supabase CLI: `supabase db push`

After applying, create your first admin user in the Supabase dashboard:
1. Go to Authentication > Users
2. Create new user with your email and password
3. Go to Table Editor > admin_users
4. Insert row: id = (copy user UUID from auth.users), email = your email, role = 'admin'
  </instructions>
  <verification>Check Supabase dashboard: admin_users table exists with your admin user row</verification>
  <resume-signal>Type "done" when migration applied and admin user created</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Create auth utilities and middleware for route protection</name>
  <files>src/lib/auth/session.ts, src/lib/auth/roles.ts, src/middleware.ts</files>
  <action>
Create three files:

**src/lib/auth/session.ts:**
- Export async function `getSession()`: calls server supabase client, returns `supabase.auth.getSession()`, handles errors gracefully
- Export async function `getUser()`: calls getSession, returns user object or null
- Export async function `requireAuth()`: calls getUser, throws error if null (for use in Server Components/Actions that require auth)

**src/lib/auth/roles.ts:**
- Export async function `isAdmin(userId: string): Promise<boolean>`: queries admin_users table for matching user, returns true if found with role='admin'
- Export async function `requireAdmin()`: calls getUser, then isAdmin, throws error if not admin (use in admin routes)
- Use Zod to validate admin_users query response

**src/middleware.ts:**
- Export default middleware function that protects /admin routes
- Check session with `supabase.auth.getSession()`
- If no session: redirect to /login
- If session exists: verify isAdmin, if not admin: redirect to / with error
- Use Next.js middleware matcher: `export const config = { matcher: '/admin/:path*' }`
- Handle middleware edge runtime compatibility (use createServerClient from @supabase/ssr with minimal cookies access)

AVOID: Don't use client-side auth checks for security (only server). Don't store role in JWT (query database for role). Don't use deprecated getUser() (use getSession()).
  </action>
  <verify>ls src/lib/auth/ shows session.ts and roles.ts, ls src/ shows middleware.ts, files have no TypeScript errors</verify>
  <done>Auth utility functions exist, middleware protects /admin routes, TypeScript validates, no eslint errors</done>
</task>

<task type="auto">
  <name>Task 3: Create login page with email/password form</name>
  <files>src/app/login/page.tsx, src/app/login/actions.ts</files>
  <action>
Create login page and server actions:

**src/app/login/page.tsx:**
- Server Component that renders login form
- Use shadcn/ui components (Card, Label, Input, Button) for consistency
- Form with email and password fields
- Submit button that calls server action
- Show error message if login fails
- Client component for form interactivity (use "use client" directive)

**src/app/login/actions.ts:**
- Export async server action `loginAction(formData: FormData)`
- Validate email/password with Zod (required, email format)
- Call `supabase.auth.signInWithPassword({ email, password })`
- If success: redirect to /admin
- If error: return error message (invalid credentials, etc.)
- Use Next.js redirect() for navigation after successful login

Follow conventions:
- Use @/ path aliases
- Named exports for components
- Server action pattern with "use server" directive in actions.ts
- Tailwind utility classes with cn() for styling
- Error handling with try-catch

AVOID: Don't use client-side signIn (security risk). Don't store password in state (use FormData directly). Don't use cookies directly (Supabase handles this).
  </action>
  <verify>Visit http://localhost:3000/login shows form, TypeScript compiles, no errors in browser console</verify>
  <done>Login page renders, form submits to server action, validation works, TypeScript has no errors</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Login page with email/password authentication</what-built>
  <how-to-verify>
    1. Run: npm run dev
    2. Visit: http://localhost:3000/login
    3. Try invalid credentials: Should show error message
    4. Try valid admin credentials (created in Task 1): Should redirect to /admin
    5. After login, visit /admin: Should stay on /admin (not redirect to /login)
    6. Open new incognito window, visit /admin: Should redirect to /login (middleware working)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

<task type="auto">
  <name>Task 4: Create admin layout with logout and navigation</name>
  <files>src/app/admin/layout.tsx, src/app/admin/page.tsx, src/components/admin/header.tsx</files>
  <action>
Create admin dashboard structure:

**src/app/admin/layout.tsx:**
- Server Component that wraps all /admin routes
- Call requireAdmin() to verify access (double-check after middleware)
- Render AdminHeader component and {children}
- Use consistent layout pattern from existing app/layout.tsx

**src/app/admin/page.tsx:**
- Admin dashboard homepage
- Display: "Welcome, [email]" with user email from getUser()
- Show placeholder cards for future features: Blog Management, Automation Logs, Analytics, Testimonials
- Use shadcn/ui Card components
- Links to future admin sub-routes (greyed out/disabled for now)

**src/components/admin/header.tsx:**
- Client Component with "use client" directive
- Display admin email and logout button
- Logout button calls server action to supabase.auth.signOut() and redirects to /
- Use shadcn/ui Button and navigation components
- Match styling patterns from existing Header component

Follow patterns:
- Server Components by default, "use client" only when needed
- Server actions for logout (not client-side signOut)
- Consistent styling with existing marketing site
- Error handling for all async operations

AVOID: Don't duplicate marketing site navigation in admin (separate header). Don't use client-side logout without server action (cookies won't clear properly).
  </action>
  <verify>Visit http://localhost:3000/admin shows dashboard with welcome message and logout button, no TypeScript errors</verify>
  <done>Admin layout renders, logout works, dashboard shows user email, navigation structure ready for future features</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Admin dashboard with layout, navigation, and logout functionality</what-built>
  <how-to-verify>
    1. Run: npm run dev (if not still running)
    2. Visit: http://localhost:3000/login and login with admin credentials
    3. Should redirect to: http://localhost:3000/admin
    4. Verify: Welcome message shows your email
    5. Verify: Dashboard shows placeholder cards for future features
    6. Click logout button
    7. Verify: Redirected to / (homepage)
    8. Try to visit /admin again: Should redirect to /login (logged out)
  </how-to-verify>
  <resume-signal>Type "approved" when verified, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Migration file created (admin_users table schema valid)
- [ ] Auth utilities (session.ts, roles.ts) exist with proper error handling
- [ ] Middleware protects /admin routes (redirects unauthorized users)
- [ ] Login page works end-to-end (validation, authentication, redirect)
- [ ] Admin dashboard accessible only after login
- [ ] Logout functionality works (clears session, redirects to /)
- [ ] No TypeScript errors: npm run build succeeds
- [ ] No breaking changes to marketing site (/ routes still work)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Authentication flow works: login → /admin → logout → /
- Middleware correctly protects /admin routes
- Admin role verification prevents non-admin users from accessing dashboard
- No console errors or TypeScript issues
- Marketing site remains fully functional
  </success_criteria>

<output>
After completion, create `.planning/phases/09-authentication-authorization/09-01-SUMMARY.md`:

---
phase: 09-authentication-authorization
plan: 01
type: execute
subsystem: auth
requires: []
provides: ["authentication", "admin-authorization", "protected-routes"]
affects: [10, 11, 12, 13]
tech-stack:
  added: ["Supabase Auth", "Next.js middleware", "admin_users table"]
  patterns: ["Server-side auth checks", "Role-based access control", "Server actions for auth operations"]
key-decisions:
  - "Email/password auth with Supabase Auth (no social providers yet)"
  - "admin_users table for role tracking (separate from auth.users)"
  - "Next.js middleware for route protection at /admin/*"
  - "Server-side role verification in both middleware and layout (defense in depth)"
key-files:
  - "src/lib/auth/session.ts"
  - "src/lib/auth/roles.ts"
  - "src/middleware.ts"
  - "src/app/login/page.tsx"
  - "src/app/admin/layout.tsx"
patterns-established:
  - "requireAuth() and requireAdmin() helpers for server components"
  - "Server actions for authentication operations (login, logout)"
  - "Middleware matcher for route protection"
  - "Admin layout pattern for dashboard features"
---

# Phase 9 Plan 1: Authentication & Authorization Summary

**Supabase Auth integration complete with role-based access control and protected admin routes**

## Accomplishments

- Created admin_users table with RLS policies for role tracking
- Built authentication utilities (session management, role verification)
- Implemented Next.js middleware to protect /admin routes
- Created login page with email/password form and Zod validation
- Built admin dashboard layout with navigation and logout
- Established server-side auth patterns for all admin features

## Files Created/Modified

- `supabase/migrations/001_auth_setup.sql` - Admin users table and RLS policies
- `src/lib/auth/session.ts` - Session management utilities
- `src/lib/auth/roles.ts` - Role verification and admin checks
- `src/middleware.ts` - Route protection middleware
- `src/app/login/page.tsx` - Login form page
- `src/app/login/actions.ts` - Authentication server actions
- `src/app/admin/layout.tsx` - Admin dashboard layout
- `src/app/admin/page.tsx` - Admin dashboard homepage
- `src/components/admin/header.tsx` - Admin header with logout

## Decisions Made

- **Email/password auth**: Using Supabase Auth's built-in email/password (simplest for single admin, can add social providers later)
- **Role table separation**: admin_users table tracks roles separately from auth.users (cleaner than custom claims)
- **Defense in depth**: Both middleware and layout verify admin role (middleware protects routes, layout double-checks)
- **Server-side verification**: All auth checks on server (middleware, server components, server actions) for security

## Issues Encountered

None.

## Next Phase Readiness

Phase 10 (Blog Management UI) can proceed. Authentication foundation complete:
- `requireAdmin()` helper ready for protecting admin-only components
- Admin layout provides consistent UI shell for all admin features
- Session management utilities available for all admin operations

</output>
