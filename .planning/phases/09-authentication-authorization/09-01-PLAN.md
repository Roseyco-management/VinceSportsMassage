---
phase: 09-authentication-authorization
plan: 01
type: execute
---

<objective>
Set up Supabase database schema for admin authentication and create core auth utilities for session management and role verification.

Purpose: Establish the foundational database structure and server-side utilities that all authentication flows depend on. This plan handles the "plumbing" - database tables, helper functions, and middleware infrastructure.
Output: Database migration with admin_users table, auth utility functions (session.ts, roles.ts), and middleware protecting /admin routes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md
@.planning/codebase/INTEGRATIONS.md
@src/lib/supabase/client.ts
@src/lib/supabase/server.ts
@src/lib/env.ts

**Tech stack available:**
- Supabase Auth (@supabase/ssr ^0.8.0, @supabase/supabase-js ^2.86.0)
- Next.js 16 App Router with Server Components
- Zod for validation (from v1.0)
- TypeScript strict mode
- Existing Supabase client/server setup with cookie-based SSR

**Established patterns:**
- Server/client component split with "use client" directive
- Zod validation for all API inputs (src/lib/validation.ts)
- Centralized environment validation (src/lib/env.ts, env.client.ts)
- Structured error handling with logger (src/lib/logger.ts)
- Path aliases (@/*) throughout codebase

**Constraining decisions:**
- v1.1: Supabase Auth chosen (existing infrastructure)
- v1.1: Admin routes at /admin (separate from marketing)
- v1.0: Zod for all validation (security standard)
- v1.0: No non-null assertions (centralized env validation)

**Database context:**
- admin_users table already defined in supabase/migrations/001_auth_setup.sql (created 2026-01-31)
- Table links to Supabase's auth.users via UUID foreign key
- RLS policies already configured for row-level security
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <action>Apply Supabase migration to create admin_users table and set up first admin user</action>
  <instructions>
The database migration file already exists at supabase/migrations/001_auth_setup.sql.

**Step 1: Apply the migration**
Option A (Supabase Dashboard - Recommended):
1. Open your Supabase project dashboard at https://supabase.com/dashboard
2. Go to SQL Editor
3. Open the file supabase/migrations/001_auth_setup.sql and copy its contents
4. Paste into SQL Editor and click "Run"

Option B (CLI):
```bash
supabase db push
```

**Step 2: Create your first admin user**
1. In Supabase Dashboard, go to Authentication > Users
2. Click "Add user" > "Create new user"
3. Enter your email and a secure password
4. Click "Create user"
5. Copy the user's UUID (id column)

**Step 3: Link user to admin_users table**
1. Go to Table Editor > admin_users
2. Click "Insert" > "Insert row"
3. Set:
   - id: [paste the UUID you copied]
   - email: [your email]
   - role: admin
4. Click "Save"

You should now have one admin user ready for testing.
  </instructions>
  <verification>Check Table Editor > admin_users shows one row with your user</verification>
  <resume-signal>Type "done" when migration applied and admin user created</resume-signal>
</task>

<task type="auto">
  <name>Task 1: Create auth session management utilities</name>
  <files>src/lib/auth/session.ts</files>
  <action>
Create src/lib/auth/session.ts with three utility functions for server-side session management:

**1. getSession()**
- Import createClient from "@/lib/supabase/server"
- Call server supabase client's auth.getSession()
- Return session object or null
- Wrap in try-catch, return null on error (don't throw)
- Add JSDoc explaining this is for Server Components/Actions only

**2. getUser()**
- Call getSession()
- Extract user from session.data.session?.user
- Return user object or null
- Add TypeScript return type annotation: Promise<User | null>

**3. requireAuth()**
- Call getUser()
- If null, throw new Error("Unauthorized - authentication required")
- Return user object (guaranteed non-null)
- Use for Server Components/Actions that MUST have auth

Add proper imports, use strict TypeScript, export all three functions as named exports.

AVOID: Don't use deprecated getUser() method from supabase client (it's being removed). Don't use client-side createClient (this is server-only). Don't store credentials or tokens manually (Supabase handles cookies).
  </action>
  <verify>cat src/lib/auth/session.ts shows three exported functions, TypeScript compiles with no errors</verify>
  <done>File exists with getSession, getUser, requireAuth functions, proper error handling, TypeScript validates</done>
</task>

<task type="auto">
  <name>Task 2: Create role verification utilities and middleware</name>
  <files>src/lib/auth/roles.ts, src/middleware.ts</files>
  <action>
Create two files for role-based access control:

**src/lib/auth/roles.ts:**
1. Create isAdmin(userId: string): Promise<boolean>
   - Import createClient from "@/lib/supabase/server"
   - Query admin_users table: `SELECT role FROM admin_users WHERE id = userId AND role = 'admin'`
   - Return true if row exists, false otherwise
   - Wrap in try-catch, return false on error (fail secure)

2. Create requireAdmin(): Promise<User>
   - Import requireAuth from "./session"
   - Call requireAuth() to get user
   - Call isAdmin(user.id)
   - If not admin, throw new Error("Forbidden - admin access required")
   - Return user object
   - Use this in admin Server Components/layouts

**src/middleware.ts:**
- Create Next.js Edge middleware that protects /admin routes
- Import createServerClient from "@supabase/ssr"
- Import NextResponse, NextRequest from "next/server"
- Export default async function middleware(request: NextRequest)
- Get session: const { data: { session } } = await supabase.auth.getSession()
- If no session: return NextResponse.redirect(new URL('/login', request.url))
- If session exists but not admin: query admin_users, if not found redirect to / with ?error=unauthorized
- If admin: return NextResponse.next()
- Export config matcher: export const config = { matcher: '/admin/:path*' }

For middleware Supabase client (Edge runtime):
```typescript
const supabase = createServerClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  {
    cookies: {
      get(name) { return request.cookies.get(name)?.value },
      set(name, value, options) { response.cookies.set({ name, value, ...options }) },
      remove(name, options) { response.cookies.set({ name, value: '', ...options }) },
    },
  }
)
```

AVOID: Don't verify role in client components (security risk). Don't cache role checks (check database each time). Don't use middleware for non-route protection logic (keep it focused).
  </action>
  <verify>Files exist, TypeScript compiles, middleware exports default function and config</verify>
  <done>Role utilities work, middleware protects /admin routes, TypeScript validates, proper error handling</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Admin user created in Supabase (checkpoint verified)
- [ ] session.ts exists with three helper functions
- [ ] roles.ts exists with isAdmin and requireAdmin
- [ ] middleware.ts exists protecting /admin routes
- [ ] TypeScript compiles: npm run build (or check in IDE)
- [ ] No console errors or import issues
</verification>

<success_criteria>

- All tasks completed
- Database migration applied (admin_users table exists)
- At least one admin user created in Supabase
- Auth utilities ready for use (session.ts, roles.ts)
- Middleware configured to protect /admin routes
- No TypeScript errors
- Ready for login UI implementation (Plan 2)
  </success_criteria>

<output>
After completion, create `.planning/phases/09-authentication-authorization/09-01-SUMMARY.md`:

---
phase: 09-authentication-authorization
plan: 01
type: execute
subsystem: auth-foundation
requires: []
provides: ["admin_users-table", "session-utilities", "role-verification", "route-middleware"]
affects: [9]
tech-stack:
  added: ["admin_users table", "auth session helpers", "Next.js middleware"]
  patterns: ["Server-side session management", "Role-based access with database queries", "Edge middleware for route protection"]
key-decisions:
  - "admin_users table for role tracking (separate from auth.users credentials)"
  - "Server-side only auth checks (no client-side verification)"
  - "Middleware redirects unauthorized users to /login"
  - "requireAdmin() throws errors for easy guard patterns in Server Components"
key-files:
  - "src/lib/auth/session.ts"
  - "src/lib/auth/roles.ts"
  - "src/middleware.ts"
  - "supabase/migrations/001_auth_setup.sql"
patterns-established:
  - "requireAuth() and requireAdmin() as guard functions"
  - "Fail-secure defaults (return false/null on errors, not throw)"
  - "Edge-compatible middleware with minimal cookie access"
---

# Phase 9 Plan 1: Authentication Foundation Summary

**[One-liner about what shipped - e.g., "Database schema and auth utilities ready for login implementation"]**

## Accomplishments

- [List key achievements]

## Files Created/Modified

- [File paths with descriptions]

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 09-02-PLAN.md (Login UI & Authentication Flow)
</output>
